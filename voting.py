# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iT83wcIHb5Fzsy5KiS4jf1Gk9jXAPk5W
"""

a = []
l = []

def generatePreferences(values):
  
  #initialise dictionary
    
    dict = {}
    """
    #store number of agents and alternatives 
    print(values.max_row+1)
    n = values.max_row+1
    m = values.max_column+1
    #loop through agents
    for i in range(1,n):
    #initialise a list which will store preference orders
        preference = []
        #looping inside alternates
        for j in range(1,m):
            #find index of alternate with high preference
            print(values[i])
            max_val = max(values[i])
            max_ind = values[i].index(max_val)
            #append index to list
            preference.append(max_ind+1)
            #Set value of alternate to 0 in order to find next high value
            values[i][max_ind] = 0
        #add preference orders to dictionary
        dict[i+1] = preference
    #return dictionary
    """
    
    for j in range (1,values.max_row+1):
            
        for i in range(1,values.max_column+1):
            
            a.append(values.cell(row=j, column= i).value) 
            
        for i in range(1,len(a)+1):
            l.append(i)
            
        #print(a)
        #print(l)
        #print(list(zip(*sorted(zip(a,l))))[1])
        m = list(zip(*sorted(zip(a,l))))[1]
        #print(list(m))
        k = list(m)
        
        dict.update({j:k[::-1]})
        l.clear()
        a.clear()  
    
        
    return dict

#dictatorship(preferenceProfile, agent)

def dictatorship(preferenceProfile, agent):
    winner = preferenceProfile[agent][0]
    return winner

def scoringRule(preferences, scoreVector, tieBreak):
    
    # check for invalid score vector
    
    if len(scoreVector) != len(preferences[1]):
        print("Incorrect input")
        return False

    # store total score of each alternative
    
    score_dict = {}

    # loop through each agent
    
    for i in range(1, len(preferences) + 1):
        agent_pref = preferences[i]

        
        # loop through each alternative
        for j in range(len(agent_pref)):
            alt = agent_pref[j]

            
            # add score to total score of alternative
            if alt in score_dict:
                score_dict[alt] += scoreVector[j]
            else:
                score_dict[alt] = scoreVector[j]

    # find alternate with highest score
    
    best_alt = -1
    
    best_val = -float('inf')
    
    for alt, val in score_dict.items():
        if val > best_val:
            best_val = val
            best_alt = alt

    
    # if tie then use tie break rule
    
    if tieBreak == "max":
        for alt, val in score_dict.items():
            if val == best_val and alt > best_alt:
                best_alt = alt
    
    elif tieBreak == "min":
        for alt, val in score_dict.items():
            if val == best_val and alt < best_alt:
                best_alt = alt
    else:
        agent_pref = preferences[tieBreak]
        for alt, val in score_dict.items():
            if val == best_val and agent_pref.index(alt) < agent_pref.index(best_alt):
                best_alt = alt

    return best_alt



def plurality(preferences, tieBreak):
    # store number of times an alternate appears in first place
    count_dict = {}

    
    # looping inside each agent
    for i in range(1, len(preferences) + 1):
        alt = preferences[i][0]

        
        # add count to total count of alterntes
        if alt in count_dict:
            count_dict[alt] += 1
        else:
            count_dict[alt] = 1

    
    # find alternate with high count
    best_alt = -1
    best_val = -float('inf')
    for alt, val in count_dict.items():
        if val > best_val:
            best_val = val
            best_alt = alt

    
    # if tie then use tie break rule
    if tieBreak == "max":
        for alt, val in count_dict.items():
            if val == best_val and alt > best_alt:
                best_alt = alt
    elif tieBreak == "min":
        for alt, val in count_dict.items():
            if val == best_val and alt < best_alt:
                best_alt = alt
    else:
        agent_pref = preferences[tieBreak]
        for alt, val in count_dict.items():
            if val == best_val and agent_pref.index(alt) < agent_pref.index(best_alt):
                best_alt = alt

    return best_alt


def veto(preferences, tieBreak):
    
    # store sum of points of every alternate
    points_dict = {}

    
    # loop inside every agent
    for i in range(1, len(preferences) + 1):
        agent_pref = preferences[i]

        # loop through every alternate
        for j in range(len(agent_pref)):
            alt = agent_pref[j]
            if j == len(agent_pref) - 1:
                points = 0
            else:
                points = 1

            # add points to total points of alternates
            if alt in points_dict:
                points_dict[alt] += points
            else:
                points_dict[alt] = points

    
    # find alternates with high points
    best_alt = -1
    best_val = -float('inf')
    for alt, val in points_dict.items():
        if val > best_val:
            best_val = val
            best_alt = alt

    
    # if, use tie break rule
    if tieBreak == "max":
        for alt, val in points_dict.items():
            if val == best_val and alt > best_alt:
                best_alt = alt
    
    elif tieBreak == "min":
        for alt, val in points_dict.items():
            if val == best_val and alt < best_alt:
                best_alt = alt
    
    else:
        agent_pref = preferences[tieBreak]
        for alt, val in points_dict.items():
            if val == best_val and agent_pref.index(alt) < agent_pref.index(best_alt):
                best_alt = alt

    return best_alt



def borda(preference_profile, tie_break):
  preferences = {alternative: 0 for alternative in preference_profile[1]}
  for agent, preference in preference_profile.items():
    for i, alternative in enumerate(preference):
      preferences[alternative] += len(preference) - i - 1
  max_score = max(preferences.values())
  possible_winners = [alternative for alternative in preferences if preferences[alternative] == max_score]
  if tie_break == "max":
    return max(possible_winners)
  elif tie_break == "min":
    return min(possible_winners)
  elif tie_break in preference_profile:
    for alternative in preference_profile[tie_break]:
      if alternative in possible_winners:
        return alternative
  return False 

def harmonic(preference_profile, tie_break):
  preferences = {alternative: 0 for alternative in preference_profile[1]}
  for agent, preference in preference_profile.items():
    for i, alternative in enumerate(preference):
      preferences[alternative] += 1 / (i + 1)
  
  max_score = max(preferences.values())
  
  possible_winner = [alternative for alternative in preferences if preferences[alternative] == max_score]
  if tie_break == "max":
    return max(possible_winner)
  elif tie_break == "min":
    return min(possible_winner)
  elif tie_break in preference_profile:
    for alternative in preference_profile[tie_break]:
      if alternative in possible_winner:
        return alternative
  return False 
preferences = {1: [1, 2, 3, 4, 5, 6], 2: [4, 5, 1, 3, 2, 6], 3: [3, 1, 2, 6, 4, 5], 4: [5, 3, 2, 1, 4, 6], 5: [3, 1, 2, 6, 4, 5], 6: [1, 2, 3, 4, 5, 6], 7: [3, 1, 2, 6, 4, 5], 8: [3, 1, 2, 6, 4, 5], 9: [1, 2, 3, 4, 5, 6], 10: [1, 2, 3, 4, 5, 6]}



def STV(preferences, tieBreak):
    while len(preferences[1]) > 1:
        #print("NK",preferences[1])
        counter = {}
        for agent in preferences:
            #print(preferences)
            preference_list = preferences[agent]
            print(preferences[agent])
            #print(counter)
            if preference_list[0] in counter:
                counter[preference_list[0]] += 1
            else:
                counter[preference_list[0]] = 1
                counter[preference_list[-1]] = 0
        print(counter)
        min_count = min(counter.values())
        max_count = max(counter.values())
        if min_count == max_count:
            break;
        print(min_count)
        losers = [alt for alt in counter if counter[alt] == min_count]
        print(preference_list)
        for agent in preferences:
            preference_list = preferences[agent]
            for loser in losers:
                if loser in preference_list:
                    preference_list.remove(loser)
            preferences[agent] = preference_list
        print(preferences[1])
    if tieBreak == 'max':
        return max(preference_list)
    
    return preferences[1][0]


# Range Voting Function

def rangeVoting(values, tieBreak):
    """preference_dict = generatePreferences(values)
    # Initialise sum of valuations to 0
    max_sum = 0
    # Initialise winner
    winner = 0
    # Iterate inside preference dictionary
    for key in preference_dict:
        # Sum of values of preference list
        sum_val = 0
        for val in preference_dict[key]:
            print(values.cell(row=key-1, column=val).value)
            sum_val += values.cell(row=key, column=val-1).value
        # Check if sum is preference list is greater than previous max sum
        if sum_val > max_sum:
            max_sum = sum_val
            # Set winner as key
            winner = key
        # Check if sum of preference list is equal to previous max sum
        elif sum_val == max_sum:
            # Check tieBreak parameter
            if tieBreak == "max":
                # Find maximum value in preference list
                max_val = max(preference_dict[key])
                # Compare maximum value with previous winner
                if max_val > preference_dict[winner][-1]:
                    winner = key
            elif tieBreak == "min":
                # Find minimum value in preference list
                min_val = min(preference_dict[key])
                # Compare minimum value with previous winner
                if min_val < preference_dict[winner][0]:
                    winner = key
            else:
                # Checking if tieBreak value is between 1 and n
                if tieBreak > 0 and tieBreak <= len(preference_dict):
                    # Find value of tieBreak in preference list
                    tie_val = preference_dict[key][tieBreak-1]
                    # Compare tieBreak value with previous winner
                    if tie_val > preference_dict[winner][tieBreak-1]:
                        winner = key
                else:
                    print("Error: Invalid tieBreak value")"""
    dict = {}
 
    
    for j in range (1,values.max_column+1):
            
        for i in range(1,values.max_row+1):
            
            a.append(values.cell(row=i, column= j).value) 
        
        #print(a)
        
        p = sum(a)
        
        #print(p)
        
        for i in range(1,len(a)+1):
            l.append(i)
        
        #print(l)
        
        #print(list(zip(*sorted(zip(a,l))))[1])
        m = list(zip(*sorted(zip(a,l))))[1]
        
        #print(list(m))
        k = list(m)
        
        
        dict.update({j:p})
        l.clear()
        a.clear()  
    print(dict)

    
    #if tieBreak == "min":
    winner = max(dict, key=dict.get) 
    
    """z = {}
    if tieBreak == 'max':
       
        for key in reversed(list(dict.keys())):
        #for key in reversed(dict):
            z[key] = dict[key]
            winner = max(z, key=z.get)
    """
        

    
    
    return winner

